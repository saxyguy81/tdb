package require tcltest 2
namespace import ::tcltest::*

package require tdb

cleanupTests

test cond-1.1 {file:line condition pauses on even hits} -body {
    set child [interp create]
    set pkgDir [file normalize [file dirname [file dirname [info script]]]]
    interp eval $child [list set ::auto_path [linsert $::auto_path 0 $pkgDir]]
    interp eval $child {
        package require tdb
        set tmp [file normalize [file join [pwd] tests tmp_cond1.tcl]]
        set fh [open $tmp w]
        puts $fh {proc demo {} {
    set sum 0
    for {set i 1} {$i <= 4} {incr i} {
        set sum [expr {$sum+$i}] ;# HIT
    }
    return $sum
}}
        close $fh
        set line -1
        set fh [open $tmp r]; set data [split [read $fh] "\n"]; close $fh
        for {set n 0} {$n < [llength $data]} {incr n} {
            if {[string match *#\ HIT* [lindex $data $n]]} { set line [expr {$n+1}]; break }
        }
        tdb::start
        catch { unset ::tdb::_stopped }
        tdb::break add -file $tmp -line $line -condition {expr {$i % 2 == 0}}
        source $tmp
        ::tdb::_ensure_exec_traces
        after 0 { demo }
        set ev1 [tdb::wait -timeout 2000]
        list [dict get $ev1 reason] [dict exists $ev1 file] [dict exists $ev1 line]
    }
} -result {breakpoint 1 1}

test hit-1.2 {file:line hitCount ==3 pauses only once} -body {
    set child [interp create]
    set pkgDir [file normalize [file dirname [file dirname [info script]]]]
    interp eval $child [list set ::auto_path [linsert $::auto_path 0 $pkgDir]]
    interp eval $child {
        package require tdb
        set tmp [file normalize [file join [pwd] tests tmp_cond2.tcl]]
        set fh [open $tmp w]
        puts $fh {proc demo {} {
    set sum 0
    for {set i 1} {$i <= 5} {incr i} {
        set sum [expr {$sum+$i}] ;# HIT
    }
    return $sum
}}
        close $fh
        set line -1
        set fh [open $tmp r]; set data [split [read $fh] "\n"]; close $fh
        for {set n 0} {$n < [llength $data]} {incr n} {
            if {[string match *#\ HIT* [lindex $data $n]]} { set line [expr {$n+1}]; break }
        }
        tdb::start
        catch { unset ::tdb::_stopped }
        tdb::break add -file $tmp -line $line -hitCount ==3
        source $tmp
        ::tdb::_ensure_exec_traces
        after 0 { demo }
        set ev [tdb::wait -timeout 2000]
        list [dict get $ev reason] [dict exists $ev file] [dict exists $ev line]
    }
} -result {breakpoint 1 1}

test log-1.3 {logpoint prints but does not pause} -constraints {LogPoints} -body {
    tdb::start
    catch { unset ::tdb::_stopped }
    set tmp [file normalize [file join [pwd] tests tmp_cond3.tcl]]
    set fh [open $tmp w]
    puts $fh {proc demo {} {
    set x 0
    for {set i 1} {$i <= 3} {incr i} {
        incr x ;# HIT
    }
    return $x
}}
    close $fh
    set line -1
    set fh [open $tmp r]; set data [split [read $fh] "\n"]; close $fh
    for {set n 0} {$n < [llength $data]} {incr n} {
        if {[string match *#\ HIT* [lindex $data $n]]} { set line [expr {$n+1}]; break }
    }
    tdb::break add -file $tmp -line $line -log {i=$i}
    source $tmp
    ::tdb::_ensure_exec_traces
    # Run and ensure we do not pause; expect wait timeout
    after 0 { demo }
    set rc [catch { tdb::wait -timeout 400 } err]
    expr {$rc == 1 && [lindex $::errorCode 1] eq "TIMEOUT"}
} -cleanup {
    tdb::break clear
    tdb::stop
    file delete -force $tmp
} -result 1

cleanupTests
